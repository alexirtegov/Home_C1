/*
G3-Последний символ - номера

В файле input.txt дана строка из не более 1000 символов. 
Показать номера символов, совпадающих с последним символом строки.
Результат записать в файл output.txt


Формат входных данных:
Строка из не более 1000 символов

Input in input.txt
aabbcdb

Формат результата:
Целые числа через пробел - номера символа, 
который совпадает с последним символом строки.

Output
2 3

Решение:
Читаем всю верёвочку от начала до конца и запоминаем, какой символ стоит в самом конце.
В примере строка “aabbcdb”, последний символ – буква “b”.
Теперь будем по порядку смотреть на каждый символ до последнего 
(не трогаем тот, что в конце).
Представь, что мы нумеруем каждый символ, начиная с 0:
– на месте 0 стоит “a”
– на месте 1 стоит “a”
– на месте 2 стоит “b”
– на месте 3 стоит “b”
– на месте 4 стоит “c”
– на месте 5 стоит “d”
(пятое место – это передпоследний символ, шестой – последний, но его мы не проверяем)
Для каждого символа спрашиваем: «Это тот же самый знак, что и наш последний?»
– На месте 0 у нас “a” – не совпадает с “b”, пропускаем.
– На месте 1 у нас “a” – пропускаем.
– На месте 2 у нас “b” – совпало! Запоминаем число 2.
– На месте 3 у нас “b” – опять совпало! Запоминаем число 3.
– На местах 4 и 5 (“c” и “d”) – не совпадают, пропускаем.
В конце у нас получилось два числа – 2 и 3. 
Это и есть ответы: именно на этих позициях (до последнего символа) стоят буквы “b”, как и в конце строки.
Записываем эти числа через пробел в выходной файл.
В нашем примере получится:
2 3
*/

// Для строки

//~ #include <stdio.h>

//~ int main() {
    //~ char s[1001];              // буфер для входной строки (до 1000 символов)
    //~ if (scanf("%1000s", s) != 1)  // читаем строку
        //~ return 0;    
                   
        //~ // считаем длину вручную
    //~ int n = 0;
    //~ while (s[n] != '\0') {
        //~ n++;
    //~ }

    //~ if (n == 0)
        //~ return 0;              // если вдруг пустая строка, просто выходим

    //~ char last = s[n - 1];      // запоминаем последний символ
    //~ for (int i = 0; i < n - 1; i++) {  // перебираем все символы, кроме последнего
        //~ if (s[i] == last) {
            //~ printf("%d ", i);         // печатаем индекс i, если символ совпал
        //~ }
    //~ }
    //~ return 0;
//~ }

//для файла

	//~ #include <stdio.h>
	//~ int main() 
//~ {
	//~ //создаем директорию filepath_in и filepath_out
	//~ char *filepath_in = "C:\\FILE\\input.txt";
	//~ char *filepath_out = "C:\\FILE\\output.txt";
	
	//~ // открываем файл input.txt для чтения
	//~ FILE*in;
	//~ in = fopen(filepath_in, "r");
		//~ if(in == NULL){
		//~ printf("Error:\n");
		//~ perror("filepath_in");
		//~ return 1;
	//~ }
	
	//~ //создем буфер и читаем в него нашу строчку scanf автоматом пропише в конце '\0'
	//~ char buffer[1001];
	//~ if(fscanf(in, "%1000s", &buffer[0])!=1){
		//~ printf("Error");
		//~ fclose(in);
		//~ return 1;
	//~ }
	//~ fclose(in);
	
	//~ //считаем нашу строку в buffer[1001] по символьно в переменную count
	//~ int count = 0;
	//~ while(buffer[count]!= '\0'){
		//~ count ++;
	//~ }
	//~ //запоминаем последний символ в переменную last
	//~ char last = buffer[count-1]; // в buffer[count] лежит '\0' а перед ним наш символ

	//~ //открываем второй файл output.txt для записи
	//~ FILE*out;
	//~ out = fopen(filepath_out, "w");
	//~ if (out == NULL){
		//~ printf("Error:\n");
		//~ perror("filepath_out");
		//~ return 1;
	//~ }
	
	//~ // записываем в output.txt результат перебора массива buffer[count-1]
	//~ for(int i =0; i<count-1; i++){
		//~ if(buffer[i] == last){
			//~ fprintf(out, "%d ", i);
		//~ }
	//~ }
	
	//~ fclose(out);
	
	
	//~ return 0;
//~ }


//без диретокрии

	#include <stdio.h>
	int main() 
{

	
	// открываем файл input.txt для чтения
	FILE*in;
	in = fopen("input.txt", "r");
		if(in == NULL){
		printf("Error:\n");
		perror("filepath_in");
		return 1;
	}
	
	//создем буфер и читаем в него нашу строчку scanf автоматом пропише в конце '\0'
	char buffer[1001];
	
	if(fgets(buffer, sizeof(buffer), in) == NULL){
		printf("Error");
		fclose(in);
		return 1;
	}
	
	//убираем '\n', если в файле он есть
	//есои не убрать '\n' то строка aabbcdb прочитается как aabbcdb\n и в конце добавится '\0'
	int len = 0;
	while(buffer[len]!='\0' && buffer[len]!='\n'){
		len ++;
	}
	if(buffer[len] == '\n'){
		buffer[len] = '\0';
	}

	
	fclose(in);//закрываем
	
	//считаем нашу строку в buffer[1001] по символьно в переменную count
	int count = 0;
	while(buffer[count]!= '\0'){
		count ++;
	}
	//запоминаем последний символ в переменную last
	char last = buffer[count-1]; // в buffer[count] лежит '\0' а перед ним наш символ

	//открываем второй файл output.txt для записи
	FILE*out;
	out = fopen("output.txt", "w");
	if (out == NULL){
		printf("Error:\n");
		perror("filepath_out");
		return 1;
	}
	
	// записываем в output.txt результат перебора массива buffer[count-1]
	for(int i =0; i<count-1; i++){
		if(buffer[i] == last){
			fprintf(out, "%d ", i);
		}
	}
	
	fclose(out);
	
	
	return 0;
}
