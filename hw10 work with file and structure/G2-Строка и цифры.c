/*
G2-Строка и цифры

Считать число N из файла input.txt. 
Сформировать строку из N символов. 
N четное число, не превосходящее 26. 
На четных позициях должны находится 
четные цифры в порядке возрастания, 
кроме 0, на нечетных позициях - заглавные буквы 
в порядке следования в английском алфавите. 
Результат записать в файл output.txt


Формат входных данных:
Четное N ≤ 26

Input in input.txt
10

Формат результата:
Строка из английских букв и цифр

Output
A2B4C6D8E2

Решение:
1)Организация работы со входным файлом +
• Переменная «файловый дескриптор» или «указатель на файл» (например: in_file). +
• Переменная целого типа N для хранения прочитанного числа. +
• Открываем input.txt в режиме чтения, проверяем успешность. +
• С помощью приёмника чисел (например, функции или метода чтения целого) 
считываем из in_file значение в N. +
• Закрываем input.txt. +

2)Проверка корректности N +
• Проверяем, что N чётное (N % 2 == 0) и N ≤ 26. +
• Если условие не выполняется, можно прервать работу программы 
или вывести сообщение об ошибке. +
• Если всё в порядке, переходим дальше.+ 

3)Подготовка исходных последовательностей+
– Массив букв: заводим массив из 26 символов (char letters[26] или аналог).
• Заполняем его с «A» по «Z» по порядку.
• Это можно сделать либо явной инициализацией, 
либо с помощью формулы (символ ‘A’ + индекс).
– Массив цифр: массив из четырёх символов (char digits[4] или аналог).
• Элементы: ‘2’, ‘4’, ‘6’, ‘8’.
• Порядок фиксированный — именно в таком порядке.+

4)Результирующая строка+
• Понадобится буфер-переменная для итогового текста длиной N+1 
(плюс один символ для терминирующего нуля, если это язык C-подобный).
• Назовём её result_string.
• Изначально заполнять ничего не нужно — достаточно знать, 
что у нас есть место ровно под N символов и завершающий нуль.

5)Счётчики для индексации+
• Счётчик букв: int letter_index = 0;
• Счётчик цифр: int digit_index = 0;
Эти счётчики показывают, какой именно элемент массива letters или 
digits мы возьмём в следующий раз.

6)Построение строки циклом по позициям 1…N
• Переменная цикла pos от 1 до N (или от 0 до N−1, в зависимости от стиля).
• На каждой итерации:
– Если pos нечётный, берём букву: читаем letters[letter_index], 
записываем её в result_string в текущую позицию, затем letter_index++ (следующая буква).
– Если pos чётный, берём цифру: читаем digits[digit_index], 
записываем её в result_string, затем digit_index++ 
(и, если digit_index дошёл до длины массива цифр, то сбрасываем digit_index = 0, 
чтобы начать круг снова).
• Таким образом, на нечётных местах всегда буквы A, B, C… в порядке возрастания, 
а на чётных — цифры 2,4,6,8,2,4… по циклу.

7)Завершение строения строки
• Если нужно, в конце result_string помещаем символ конца строки (например, ‘\0’), 
чтобы можно было её вывести как «C-style» строку.
• В языках без ручного управления терминирующим нулём этот шаг либо не нужен, 
либо реализуется автоматически.

8)Запись в выходной файл
• Открываем output.txt в режиме записи (файловый дескриптор out_file).
• Пишем в него весь буфер result_string единовременно — ровно N символов, 
без добавочных пробелов или переводов строки (если формат не требует).
• Закрываем output.txt.


объяснение задачи:
Представь себе, что ты раскладываешь цепочку из N бумажных карточек на столе, 
пронумеровав их слева направо от 0 до N−1 (хотя люди обычно считают «с единицы», 
компьютер чаще начинает с нуля). Теперь на каждую карточку ты хочешь поочерёдно 
приклеивать сначала букву, потом цифру, снова букву, снова цифру и так далее,
пока не заполнится весь ряд.

В коде это выглядит так:

Мы заводим переменную pos, она бежит по всем позициям от 0 до N−1.
На каждой итерации проверяем остаток от деления pos на 2:
– Если остаток равен нулю (pos=0,2,4…) — значит, сейчас время клеить букву.
Мы берём из большого набора letters ту букву, на которую указывает letters_index, 
клеим её, а потом увеличиваем letters_index на 1. Когда letters_index доходит 
до конца алфавита (26 букв), мы возвращаем его к нулю, чтобы снова начать с «A».
– Если остаток от деления на 2 равен единице (pos=1,3,5…) — клеим цифру.
Цифры лежат в массиве digits (у нас четыре: «2», «4», «6», «8»). 
Мы берём текущую digits_index-ую цифру, клеим, увеличиваем digits_index и, 
дойдя до конца массива цифр, снова «перезапускаемся» с нуля.
В результате на позициях 0,2,4… окажутся буквы, а на 1,3,5… — цифры, 
и они будут циклически повторяться.
Когда вся строка заполнена, на выходе остаётся массив символов of length N, 
но чтобы компилятор и функции вывода «поняли», где строка кончается, 
в ячейку с индексом N мы кладём «пустой символ» '\0'. Это просто обозначение конца текста.
Итог: после цикла у тебя в result_string получится что-то вроде
A2B4C6D8E2…
строка ровно из N символов, с чередованием буква–цифра–буква–цифра, 
а в конце стоит признак конца строки.

*/


#include <stdio.h>

int main(int argc, char **argv)
{
	FILE*file;
	
	//откроем файл input.txt для чтения
	file = fopen("input.txt", "r");
	if(file == NULL){
		perror("input.txt");
		return 1;
	}
	//через fscanf считываем число из файла и записываем в N,затем закрываем файл
	int N=0;
	if(fscanf(file, "%d", &N)!=1){
		printf("Error");
		fclose(file);
		return 1;
	}
	fclose(file);
	
	//проверяем на условие N чётное (N % 2 == 0) и N ≤ 26.
	if(N%2!=0 || N>26){
		printf("Error");
		return 1;
	}
	
	// создаем массив букв и цифр
	char letters[26];			 //можно так char letters[26] = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
	for (int i=0; i<26; i++){
		letters[i] = 'A'+i;
	} 

	
	char digits[4] = {'2', '4', '6', '8'};

	//создаем массив буфер (последний под '\0').
	char result_string [N+1];
	
	// индексы для перебора букв и цифр
	int letters_index = 0;
	int digits_index = 0;

	//построение строки по позициям 1…N
	for(int pos = 0; pos<N; pos++){
		// Если позиция чётная (pos = 0, 2, 4 …), 
		//это «нечётное» место в понимании задачи
		if((pos%2) ==0){
			// Берём следующую букву и увеличиваем 
			//letter_index, при выходе за границу — обнуляем
			result_string[pos] = letters[letters_index];
			letters_index++;
			if (letters_index>=sizeof(letters)){ //Когда letters_index доходит до конца алфавита 
				//(26 букв), мы возвращаем его к нулю, чтобы снова начать с «A».
				letters_index = 0;
			}
		} else {
			  // На «чётных» местах (pos = 1, 3, 5 …) ставим цифру
			  result_string[pos] = digits[digits_index];
			  digits_index++;
			  if(digits_index>= sizeof(digits)){ //digits_index дойдет до 4 обнуляем
				  digits_index = 0;
			  }
		}
		
	}
	result_string[N] = '\0';
	
	//открываем выходной файл output.txt
	FILE*file2;
	file2 = fopen("output.txt", "w"); //открываем в формате записи
		if(file2 == NULL){
		perror("output.txt");
		return 1;
	}
	
	//пишем в выходной файл буфер  result_string[N]
	fprintf(file2, "%s", result_string);
	fclose(file2);
	

	return 0;
}

