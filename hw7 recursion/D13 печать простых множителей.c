/*
D13-Печать простых множителей

Составить рекурсивную функцию, 
печать всех простых множителей числа.

Формат входных данных:
Одно натуральное число.


Формат результата:
Последовательность из всех простых делителей 
числа через пробел
*/
//вариант 1

#include <stdio.h>
/*
 *Понять, какое состояние алгоритма хранится в переменных в каждый момент:
– в нашей задаче состояние — это два числа:
• n (то, что осталось разложить на простые множители)
• i (текущий кандидат в простые делители, точно так же, как индекс цикла for)
Определить базовый случай, когда больше ничего делать не нужно:
– цикл завершался, когда i > n или n==1 → значит, в рекурсии мы прекращаемся, если n <= 1 или i > n.
Сформулировать шаг рекурсии так, чтобы он приближал к базовому случаю, уменьшая «размер» задачи:
– если i делит n, мы «снимаем» этот множитель: печатаем i и рекурсивно обрабатываем n/i с тем же i (n уменьшается).
– иначе переходим к следующему кандидату i+1, оставляя n прежним (i растёт).
 */

void print_simple_rec(int n, int i) {//12 и 2
  
    if (n <= 1 || i > n) {
        return;
    }

   
    if (n % i == 0) {
        printf("%d ", i);
        print_simple_rec(n / i, i);
    }
    
    else {
        print_simple_rec(n, i + 1);
    }
}

// Обёртка: начинаем факторизацию n с i = 2
void print_simple(int n) {
    print_simple_rec(n, 2);
}

int main(void) {
    int N;
    if (scanf("%d", &N) != 1 || N < 2) {
        printf("Error input\n");
        return 1;
    }
    print_simple(N);
    return 0;
}





//вариант 2 обычный
//~ #include <stdio.h>

//~ void print_simple(int n){
    //~ // Проходим по потенциальным простым делителям от 2 до n
    //~ for (int i = 2; i <= n; i++) {
        //~ // Пока i — делитель n, выводим i и уменьшаем n
        //~ while (n % i == 0) { 
            //~ printf("%d ", i);
            //~ n /= i;
        //~ }
    //~ }
	
//~ }

//~ int main()
//~ {
	//~ int N;
	//~ if(scanf("%d", &N)!=1){
		//~ printf("Error input");
		//~ return 1;
	//~ }
	
	//~ print_simple(N);
	
	//~ return 0;
//~ }
