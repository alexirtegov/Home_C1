/*
Проверь мою логику: 
допустим у меня есть int D. 
Беру указатель int*gpt_1 и присваеваю указателю адрес переменной D.
gpt_1=&D; Теперь gpt_1  указывает на память где находиться значение D.

Допустим D=75368. Запись этого числа будет: 
N = b₀ + b₁·256 + b₂·256² + … + bₖ·256ᵏ,
 b₀ = 75368 mod 256 = 104
 b₁ = (75368/256) mod 256 = 294 mod 256 =38
 b2 = (75368/256^2) mod 256 = 1 mod 256=1
N= 104+ 38*256+1*256^2 другими словами запись будет 104 38 1

– В памяти (&D) будет, байт за байтом:
[0x68=104] [0x26=38] [0x01=1] [0x00=0].

Возьму еще один указатель gpt_2, но не на int, а на char:
char*gpt_2  и присвою тот же адрес переменной D: 
unsigned char*gpt_2=(unsigned char*)&D;

Если сейчас я выведу адреса указателей, то должен увидеть:
1) printf("%p", gpt_1);  адресс &D
2) printf("%p", gpt_2);  точно такаой же адресс &D

НО! Если сейчас я выведу значения указателей, то должен увидеть:
1) printf("%d", *gpt_1);  значение 75368
2) printf("%d", *gpt_2);  значение 104, так как байты, 
где записаны все значения 104 38 1 числа 75368 в char не войдут,
войдет только первый с числом 104


Если сейчас я присвою через указатель *gpt_2=1, в пямяти &D поменяется
значение первого байта: было 104 станет 1: 1 38 1,

теперь память выглядит так:
[0x01=1] [0x26=38] [0x01=1] [0x00=0].

соответственно *gpt_2 примет значение 1
соответственно *gpt_1 примет значение 1+38*256+256^2=75265
если мы выведем printf ("*gpt_2=%d", *gpt_2); получим 1
если мы выведем printf ("*gpt_1=%d", *gpt_1); получим 75265


При этом адреса останутся прежними:
1) printf("%p", gpt_1);  адресс &D
2) printf("%p", gpt_2);  точно такаой же адресс &D

– Чтобы вывести адрес указателя корректно и без предупреждений компилятора, приводите к void*:
     printf("%p\n", (void*)gpt_1);
     printf("%p\n", (void*)gpt_2);

*/

#include <stdio.h>

int main(int argc, char **argv)
{
	int D=6;
	int*gpt_1=&D;
	unsigned char*gpt_2=(unsigned char*)&D;
	
	//Если сейчас я выведу адреса указателей, то должен увидеть что адреса сохранились:
	printf("adress gpt_1 is %p\n", gpt_1);  //адресс &D
	printf("adress gpt_2 is %p\n", gpt_2);  //точно такаой же адресс &D
	
	//НО! Если сейчас я выведу значения указателей, то должен увидеть:
	printf("\nmeaning *gpt_1 and *gpt_2 before \n");
	printf("*gpt_1 = %d\n", *gpt_1);  //значение 75368
	printf("*gpt_2 = %d\n", *gpt_2);  //значение 104, так как байты, 
	
		
	*gpt_2=1;
	printf("\nmeaning *gpt_1 and *gpt_2 after *gpt_2=1;\n");
	printf("*gpt_1 = %d\n", *gpt_1);  //значение 75265
	printf("*gpt_2 = %d\n", *gpt_2);  //значение 1, так как байты, 
	
	//При этом адреса останутся прежними:
	printf("\nadress gpt_1 is %p\n", gpt_1);  //адресс &D
    printf("adress gpt_2 is %p\n", gpt_2);  //точно такаой же адресс &D
	return 0;
}

