/*
F10-Упаковать строку

Дана строка состоящая из маленьких латинских букв 'a'..'z'. 
В конце строки точка. 
Необходимо заменить повторяющиеся буквы на <буква><количество повторений>


Input
Входная строка состоящая из букв 'a'-'z' не превышающая 1000 символов. 
В конце строки символ '.'
aaaaabbbc.


Формат результата:
Результат состоящий из букв и чисел, без пробелов
Output
a5b3c1

Решение:
Для решения задачи «упаковки» строки достаточно одного прохода по символам, 
без каких-либо дополнительных структур. 

1.Прочитать входную строку посимвольно до точки, не включая саму точку.
2.Если в строке нет ни одного символа (первым же символом идёт точка), просто вывести пустую строку и закончить.
3. Завести две вспомогательные переменные:
– current_char – чтобы хранить букву, которую мы сейчас «складываем»;
– count – чтобы считать, сколько раз она встречается подряд.
4. Инициализировать current_char первым символом строки, count = 1.
5. Перейти ко второму символу и дальше по всем символам подряд, пока не встретим точку:
– Если очередной символ совпал с current_char, увеличить count на единицу.
– Если отличается, то в выходную строку дописать сначала current_char, потом значение count, и затем:
• обновить current_char на текущий символ,
• сбросить count = 1.
6. Когда дошли до точки (или до конца входа), в любом случае в результат дописать ещё один «пакет» – current_char и count.
7. Вывести полученную строку без пробелов и без точки.

На примере «aaaaabbbc.» алгоритм будет работать так:
– current_char = ‘a’, count растёт от 1 до 5, потом встречается ‘b’ → выписываем «a5» и начинаем считать для ‘b’.
– Для ‘b’ count = 3, затем появляется ‘c’ → выписываем «b3», начинаем считать ‘c’.
– Для ‘c’ count = 1, дальше точка → в итог добавляем «c1».
Итоговая строка: a5b3c1.
*/

// Вариант через getchar
/*
	    getchar() — это низкоуровневая функция «читай один символ». Она вернёт очередной байт из потока ввода (или EOF), но ни о 
		каком окончании строки или терминаторе не думает. 
		функции "посимвольного ввода" (getchar, fgetc, scanf с %c) автоматически не подставляют '\0'.
*/
//~ #include <stdio.h>


//~ int main(int argc, char **argv)
//~ {
	
	
	  //~ //Прочитать входную строку посимвольно до точки, не включая точку
	


	//~ int c;
	//~ c = getchar(); //читаем первый символ для примера aaaaabbbc. это a
	//~ if(c==EOF || c == '.'){
		//~ return 0; //если точка выходим
	//~ }
	
	//~ char current_char;
	//~ int count;
	
	//~ current_char = (char)c;
	//~ count = 1;
	
	//~ while((c=getchar()) !=EOF && c!='.'){ //считываем остаток  по символам aaaabbbc.
		//~ if((char)c == current_char){
			//~ count++;
		//~ } else {
			 //~ printf("%c%d", current_char, count);
			 //~ current_char = (char)c;
			 //~ count =1;
		 //~ }
	//~ }
	


	//~ printf("%c%d", current_char, count);
	 
	
	

	//~ return 0;
//~ }

//вариант 2 через scanf

#include <stdio.h>
#define SIZE 1000


int main(int argc, char **argv)
{
	  //Прочитать входную строку посимвольно до точки, не включая точку
/* 
	 1) Форматный спецификатор "%s" в scanf — это именно «считывание строки». Он читает символы до пробела (или другого разделителя), 
     	заносит их в буфер и после последнего записанного символа сам кладёт '\0', чтобы вы получили корректную C-строку.
	    все функции «для строк» (scanf с %s, fgets и т. п.) автоматически добавляют '\0'
*/
	char array[SIZE+1]; // +1 нужен чтобы мы могли вписать '\0'
	
	if(scanf("%1000[^.].", array)!=1){    // %1000[^.]  — считать до 1000 любых символов, кроме точки, . — затем «съесть» саму точку (literal ‘.’),
		return 0;
	}
	
	if(array[0] == '\0'){//строка пуста выход
		return 0;
	}
	
	char current_char = array[0];
	int count=1;
	
	//перебираем строку
	for (int i =1; array[i]!= '\0'; i++){
		if(array [i] == current_char){ //СРАВНИВАЕМ НЕ СИМВОЛЫ А ЗНАЧЕНИЯ ТАБЛИЦЫ ASCII
			count++;
		} else{
		printf("%c%d", current_char, count);
		current_char=array[i];
		count=1;
		}
		
	}
	
	printf("%c%d", current_char, count);
		
	return 0;
}
	
	
	


