/*
Вызов из main

В main мы пишем factorial(3);. 
Это означает: запускаем расчёт факториала для n=3 
и выводим промежуточные шаги.

Первый уровень рекурсии (n=3)

При входе в factorial(3) на экран выводится строка 3
Затем проверка if (n <= 1) даёт false, потому что 3>1. 
Далее выполняется выражение int _f = 3 * factorial(2);
— перед тем как умножить на 3, нужно узнать результат factorial(2).

Второй уровень (n=2)

Входя в factorial(2), функция сначала печатает 2
проверка 2 <= 1 даёт false, поэтому происходит рекурсивный вызов 
factorial(1) внутри выражения 2 * factorial(1).

Третий уровень (n=1)

При factorial(1) сразу выводится1
Условие if (1 <= 1) истинно, поэтому функция возвращает 1, 
не делая дальнейших вызовов.

Возврат к n=2

Теперь мы знаем factorial(1) == 1. Вычисляется _f = 2 * 1 = 2, 
затем строка 2*factorial(1)=2
выводится с помощью printf("%d*factorial(%d)=%d\n", 2, 1, 2);. 
Функция factorial(2) возвращает 2.

Возврат к n=3

Вычисление на уровне n=3 продолжается: _f = 3 * 2 = 6. 
Потом печатается3*factorial(2)=6
и factorial(3) возвращает 6.

Итоговый вывод

Вся программа напечатает ровно в таком порядке (каждое на новой строке):
3
2
1
2factorial(1)=2
3factorial(2)=6

Стек вызовов при этом выглядит так (сверху – первый вызов, внизу – самый глубокий):

factorial(3)
→ внутри него вызов factorial(2)
→ внутри него вызов factorial(1)
← возвращается 1 в factorial(2)
← возвращается 2 в factorial(3)
возвращается 6 в main

Таким образом, с помощью печати перед и после рекурсивного вызова мы видим, 
как функция «спускается» по значениям n от 3 до 1, достигает базового случая 
n≤1, а затем «поднимается» обратно, вычисляя и выводя результаты умножения 
на каждом уровне.
*/

#include <stdio.h>

unsigned int factorial(unsigned int n) {
printf("%d\n", n);
if (n <= 1)
return 1;
int _f = n * factorial(n - 1);
printf("%d*factorial(%d)=%d\n", n, n - 1, _f);
return _f;
}

int main(void) {
int fac = factorial(3);
printf("%d\n", fac);
return 0;
}
