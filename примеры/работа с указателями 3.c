/*
Если я создам переменную int g=4; это значит я взял 4 байта в опретивной памяти, куда записал значение 4

 g=4. Запись этого числа будет: 
N = b₀ + b₁·256 + b₂·256² + … + bₖ·256ᵏ,
b₀ = 4 mod 256 = 4
b₁ = (4/256) mod 256 = 0
b₂ = (4/256²) mod 256 = 0
b₃ = (4/256³) mod 256 = 0

N= 4+ 0*256 другими словами запись будет 4 0 0 0

– В памяти (&g) будет, байт за байтом:
[0x04=4] [0x00=0] [0x00=0] [0x00=0].

теперь я создал указатель типа int *gpt=&g и присвоил ему адресс g.

при команде вывода:
printf("g=%d, adress (hex) is %p, adress (dec) is %u\n", g, gpt, gpt);
я выведу по очередно значения: 4, адресс &g в шестнадцетиричной записи и адресс в десятиричной записи,

далее я сделаю команду 
gpt++;

при команде вывода:
printf("g=%d, adress (hex) is %p, adress (dec) is %u\n", g, gpt, gpt);
я выведу по очередно значения: 4, адресс &g в шестнадцетиричной записи и адресс в десятиричной записи,
адреса в шестнадцетиричной и десятиричной записи будут на 4 единицы больше чем старые.

далее я сделаю команду 
gpt+=3; Учитывая, что в int 4 байта, теперь я три раза должен перейти область в 4ре байта,
то есть я сразу перемещаюсь в памяти на 12 байтов от прошлого адреса

 */

#include <stdio.h>
#include <inttypes.h>

int main(void) {
    unsigned int g = 4;
    unsigned int *gpt = &g;

    // правильная печать
    printf("g = %u\n", g);
    printf("address (hex) : %p\n", (void*)gpt);
    printf("address (dec) : %" PRIuPTR "\n", (uintptr_t)gpt);

    gpt++;

    printf("\nafter gpt++:\n");
    printf("address (hex) : %p\n", (void*)gpt);
    printf("address (dec) : %" PRIuPTR "\n", (uintptr_t)gpt);
    
    gpt+=3;
//то есть я сразу перемещаюсь в памяти на 12 байтов от прошлого адреса
    printf("\nafter gpt++:\n");
    printf("address (hex) : %p\n", (void*)gpt);
    printf("address (dec) : %" PRIuPTR "\n", (uintptr_t)gpt);

    return 0;
}
