/*
Проверь мою логику: 
допустим у меня есть char D, данная переменная записалась по адресу 12345. 
Беру указатель char*gpt, чтобы мне работать с моими данными char D, по адресу 12345, 
я должен присвоить gpt = 12345. 
Теперь мой указатель указывает на мою память где находиться значение D.
Допустим D=10. Теперь, если я хочу считать значение по моему адресу 12345 
я должен указать новую переменную char x =*gpt; 
если сейчас я введу printf("%d", x); я должен получить в вывод значение 10. 
Если я сейчас захочу поменять свои данные по своему адресу 12345, 
например вместо 10 положить данные 100, я укажу *gpt=100;
*/

#include <stdio.h>

int main(void) {
    char D;  //переменная, которая записалась по какому-то адресу
    char *gpt; //это указатель на тип данных формата char!! сам указатель типа int
    
    //раз мы выбрали тип char значит можем менять память по адресу до числа 128
    //если нужно больше нужно брать int
    
    
    D = 10;          // D теперь хранит 10
    printf("D = %d\n", D);   // выведет 10
    gpt = &D;        // gpt теперь указывает на D, сейчас я могу работать как с самой переменной, так и с адресом
    
    char *A; //введем еще один указатель
    A = &D; // укажем также на D
    printf("\nadress A is =%p A and gpt are equal because they point to the same variable \n", A);   // выведет тот же адрес, что и gpt
    
    char x = *gpt;   // разыменовываем – получаем 10
    printf("\nx = %d, adress gpt is %p\n", x, gpt);   // выведет 10
    
    printf("\nall parametrs: x=D=%d, D=%d, *gpt=%d, adress gpt is %p\n", x, D, *gpt, gpt);
    
    *gpt = 111;      // записываем 100 по тому же адресу
    char x1 = *gpt; 
    printf("\nall parametrs: x1=D=%d, D=%d, *gpt=%d, adress gpt is %p\n", x1, D, *gpt, gpt);   // выведет 100
    
    return 0;
}
