/*
Пример организации стека через динамический массив

realloc:
	Функция realloc изменяет размер уже выделенного блока памяти.
Она принимает два аргумента: 
	сначала указатель на ранее выделенную память (в данном случае st->item), затем новый желаемый размер.
	Если realloc может изменить размер блока, оно делает это 
	и возвращает новый указатель на тот же или другой адрес памяти.
	Если память не удается выделить, realloc возвращает NULL, и исходный блок памяти остается без изменений.

В основном, стек через динамический массив (как в этом коде) 
использует единую область памяти для хранения элементов. 
Это может быть более эффективно по памяти для небольших стеков, 
но требует перераспределения памяти при необходимости увеличения.

Стек через связный список (как в предыдущем коде) 
может проще справляться с изменениями в размере, 
так как каждый элемент создается по мере необходимости, 
без необходимости перераспределения для всей структуры.

Когда использовать **:
Используйте **, если вы хотите изменить указатель, на который ссылается переданный аргумент. 
Это требует передачи адреса самого указателя, чтобы изменения, сделанные внутри функции, 
отразились на указателе в вызывающем коде.

Когда использовать *:
Используйте *, когда вы хотите работать с содержимым структуры или объекта, не изменяя сам указатель. 
Вы просто передаете адрес структуры, чтобы функция могла изменить ее содержимое, 
но сам указатель остается неизменным.

Структура стека:
Мы определяем структуру stack с тремя полями:
	int *item: указатель на массив, который будет использоваться для хранения элементов стека.
	int size: размер стека (максимальное количество элементов, которое он может содержать).
	int sp: указатель на вершину стека (stack pointer), 
	который указывает на текущую позицию для добавления или удаления элементов.

Функция init_stack:
	Эта функция инициализирует стек, 
	выделяя память для его элементов и устанавливая начальные значения для размеров и индекса вершины. 
	Начальный размер стека здесь равен 4.
	Если выделение памяти не удается, программа завершает выполнение с ошибкой.

Функция delete_stack:
	Освобождает память, занимаемую массивом элементов стека, когда стек больше не нужен.

Функция push:
	Добавляет элемент в стек. Если вершина стека (stack pointer) достигает размера массива, 
	вызывается realloc для удвоения размера массива.
	Мы увеличиваем sp после добавления элемента, чтобы указатель переместился на следующий доступный индекс.

Функция pop:
	Удаляет верхний элемент из стека. Если стек пуст, выводится сообщение об ошибке и программа завершается.
	Уменьшается sp, и значение верхнего элемента передается в переменную, на которую указывает value.

Функция empty_stack:
	Проверяет, пуст ли стек, вызывая возврат 1 (истина) или 0 (ложь) в зависимости от состояния стека.

main функция:
	Инициализирует стек и затем в цикле добавляет элементы, считывая их с помощью scanf.
	Стек будет наполняться до тех пор, пока пользователь не введет 0.
	После этого выводятся все элементы, находящиеся в стеке, в порядке их добавления.
	Затем происходит извлечение элементов из стека, и они выводятся в порядке, обратном добавлению.
	В конце освобождается память, занимаемая стеком.
	
Универсальность памяти: 
	Каждый участник памяти представляет собой последовательность байтов, и нет никакого специального разделения 
	на массивы, структуры или другие типы данных. Это просто последовательность байтов.
Тип данных: 
	Когда вы выделяете память с помощью malloc, вы просто резервируете некоторый объем байтов. 
	Как вы будете интерпретировать эти байты (как массив, структуру или одиночную переменную) зависит от того, 
	как вы используете указатель и какие операции выполня
		
		Если вы выделяете память для массива, например, с помощью int *array = malloc(n * sizeof(int));, 
		вы интерпретируете выделенную память как массив из n элементов типа int.
		
		Если вы выделяете память для структуры, например, 
		с помощью struct Node *node = malloc(sizeof(struct Node));, 
		вы интерпретируете эту память как отдельный экземпляр структуры.
		
		Вы можете манипулировать памятью, как вам нужно, в рамках того, что вы сделали в коде. 
		Например, выделив 16 байт, вы можете использовать их как массив из четырех int, или, 
		скажем, как последовательность char, если понадобится.
*/



#include <stdio.h>
#include <stdlib.h>

// Определяем тип данных
//Указатель int *item: Это указатель, который хранит адрес в памяти, где расположен массив целых чисел 
//(то есть динамически выделенная память для хранения элементов стека). После того как вы выделяете память 
//для этого массива с помощью malloc (например, в функции init_stack), 
//item будет указывать на начало этой выделенной области памяти.
//разыменовывая указатель, мы можем вносить данные в массив. Например, в функции push:
struct stack {
    int *item; // указатель на массив целых чисел, который используется для хранения элементов стека. 
    int size;  // Размер стека (массива) будем его менять по мере заполнения индекса
    int sp;    // Указатель на вершину стека (stack pointer) - это просто индекс массива item [sp++]
}; //все три поля нужны чтобы управлять массивом. Все три поля рядом, а массив где-то в памяти.

// Функция инициализации стека
void init_stack(struct stack *st) { //принимает указатель на структуру stack. Этот указатель позволяет функции изменять содержимое переданного стека
    st->size = 4; // Начальный размер стека
    st->sp = 0;   // Устанавливаем указатель на вершину стека в 0 Это индекс массива item[]. Сначала он 0
    st->item = malloc(st->size * sizeof(int)); // Выделяем память под элементы стека эквивалентно malloc(4 * 4) или malloc(16). В эту память мы сможем записать 4 элемента int по типу массива
    //В item будет храниться адрес на первый элемент выделенного массива.
    if (st->item == NULL) {
        exit(1); // Проверка на успешное выделение памяти
    }
}//Теперь структура st инициализирована, и память для элементов стека успешно выделена. Возвращаемся в main

// Функция для освобождения памяти стека
void delete_stack(struct stack *st) {
    free(st->item); // Освобождаем память, занятую элементами стека
}

// Функция для добавления элемента в стек
void push(struct stack *st, int value) { //первоначально массив item может содержать только 4 числа размером до 4 байт, при вводе 5-го числа массив будет увеличен в два раза
    // Проверяем, нужен ли нам новый размер для стека
    if (st->sp == st->size) { // Изменено с `st->size - 1` на `st->size`
        st->size *= 2; // Увеличиваем размер в два раза
        st->item = realloc(st->item, st->size * sizeof(int)); // Р realloc для изменения размера массива
        if (st->item == NULL) {
            exit(1); // Проверка на успешное выделение памяти
        }
    }
    
    //способ обращения к выделенной через malloc(st->size * sizeof(int)) памяти через массив
    
    st->item[st->sp] = value; // Добавляем элемент и увеличиваем индекс массива на единицу
	st->sp++; //переставили индекс массива для следующей записи числа
}

// Функция для удаления элемента из стека
void pop(struct stack *st, int *value) {
    if (st->sp < 1) {
        printf("stack empty\n"); // Выводим сообщение об ошибке, если стек пуст
        exit(1);
    }
    *value = st->item[--(st->sp)]; //разыменовывая value, мы записываем значение в main по адресу a, то есть меняем саму переменную. Уменьшаем указатель на вершину и возвращаем значение
}	//индекс sp на 1 больше чем последнее значение, поэтому операция дикремента сначала
	// item[5] = {1,2,3,4,5}, соотвественно дикремент item[4] = 5


// Функция для проверки, пуст ли стек
int empty_stack(struct stack *st) {
    return (st->sp == 0); // читаем индекс массива и возвращает 1 (истина), если стек пуст
}

// Главная функция
int main() {
	
    struct stack st; // Создаем экземпляр структуры stack

    int a, i;
    init_stack(&st); // Инициализируем стек

    do {
        scanf("%d", &a); // Считываем значение
        if (a != 0) { // Только добавляем, если число не равно 0
            push(&st, a); // Добавляем элемент в стек
        }
    } while (a != 0); // Цикл продолжается, пока не введено 0

    // Выводим элементы в порядке добавления
    for (i = 0; i < st.sp; i++) {		//ограничение < st.sp отсекает вывод мусора, ессли добавить  = будем видеть одно мусорное значение
        printf("%d ", st.item[i]);
    }
    printf("\n\n");


    // Извлекаем элементы из стека и выводим их
    while (empty_stack(&st) !=1) {
        pop(&st, &a); // Извлекаем верхний элемент
        printf("%d ", a); // Выводим извлеченное значение
    }
    
    // Освобождаем память после завершения работы с стеком
    delete_stack(&st);
    
    return 0; // Успешное завершение программы
}
