/*
Когда я делаю первый раз push(&p, i); я передаю адрес нахождения моего указателя p в main. 
Создаю первую узел структуры ptmp = malloc(sizeof(struct list)); 
в поле value пишу 1, в поле указателя next пишу адрес свеого p из main, который указывает на NULL, 
а в main через *p = ptmp; записываю в переменную p новый адрес, который теперь указывает не на NULL а на первый узел структуры. 
Сейчас из main опять передаю push(&p, i);. Адрес p остался прежнем, только внутри p лежит адрес первого узла. 
Что дальше? опять создаю новый узел, в поле данных попадает значение 2, в поле указателя адрес первого узла, 
теперь через *p = ptmp; опять в main записываем по адресу p адрес второго узла и т.д. 
Получается самый первый узе у нас смотрит на NULL, остальные все к нему присоединяются!
________________________________________________________________________________________________

когда в функции void push(struct list **p, int data) 
мы пишем ptmp->next = *p; что происходит при первом вызове? 
*p смотрит на NULL? значит первый узел будет смотреть на NULL 
в поле struct list *next;
а дальше запись *p = ptmp; разыменовывая указатель p 
мы направляем p в main на ptmp.

Первый вызов push(&p, 1);
Далее, при выполнении ptmp->next = *p;, вы разыменовываете *p, 
который в этот момент указывает на NULL, так как стек пуст.
Поэтому ptmp->next устанавливается на NULL. 
Это означает, что новый узел будет последним в стеке, 
и его next указатель будет равен NULL.
Затем выполняется строка *p = ptmp;. 
Здесь вы обновляете вершину стека, чтобы она указывала на новый узел:
При этом *p (высшее значение p в main) теперь указывает на адрес 0x100,
где находится новый узел


Указатель p в main всегда указывает на верхний узел стека (самый последний добавленный узел).
Каждый узел указывает на свой предшествующий узел, таким образом формируется цепочка из узлов.

Что такое _Bool
_Bool — это встроенный тип, который может принимать одно из двух значений: 0 (ложь) или 1 (истина).
Если вы присваиваете _Bool переменной значение, отличное от нуля, то она будет интерпретироваться как true.
Если присваиваете 0, то она считается false.
*/

#include <stdio.h>
#include <stdlib.h>

// Определяем тип данных
struct list {
    int value;           // Значение элемента стека
    struct list *next;   // Указатель на следующий элемент
};


// Функция для добавления элемента в стек
// каждый новый узел в стеке указывает на предыдущий узел, 
// и это создаёт цепь узлов, где каждый узел ссылается на свой предшественник. 
void push(struct list **p, int data) {
    struct list *ptmp; // Временный указатель для нового элемента
    ptmp = malloc(sizeof(struct list)); // Выделяем память для нового узла
    if (ptmp == NULL) {
        exit(1); // Проверка на успешное выделение памяти
    }
    ptmp->value = data; // Устанавливаем значение нового узла
    ptmp->next = *p;    // Новый узел указывает на текущую вершину стека
    *p = ptmp;          // Указываем вершину стека на новый узел, меняем в main, если было NULL, теперь ptmp
}

// Функция для проверки, пуст ли стек
_Bool empty_stack(struct list *p) {
    return p == NULL; // Возвращаем true, если указатель на стек равен NULL
}

// Функция для удаления элемента из стека
int pop(struct list **p) {
    struct list *ptmp = *p; // Временный указатель на вершину стека, который изначально смотрит на последний узел
    int c;
    
    if (empty_stack(*p)) {
        exit(1); // Попытка взять из пустого стека
    }
    
    c = ptmp->value;  // Сохраняем значение узла
    *p = ptmp->next;  // Обновляем вершину стека
    free(ptmp);       // Освобождаем память, занимаемую узлом
    return c;        // Возвращаем значение
}

int main() {
    struct list *p = NULL; // Инициализация стека (вершина) - указатель на NULL
    //Указатель p в main всегда указывает на верхний узел стека (самый последний добавленный узел)
    
    for (int i = 1; i <= 5; i++) { //
        push(&p, i); // Добавляем элементы в стек
    }
    
    //используем for для вывода
    for (int i = 1; i <= 5; i++) {
        printf("%d\n", pop(&p)); // Извлекаем и выводим элементы в порядке 5, 4, 3, 2, 1
    }
    
    // Используем цикл while для извлечения и вывода элементов
    struct list *current = p; // Указатель на текущий узел для извлечения
    while (current != NULL) {
        printf("%d\n", pop(&p)); // Извлекаем и выводим элементы в порядке 5, 4, 3, 2, 1
        current = p; // Обновляем current для проверки на NULL
    }
    
    return 0;
}
