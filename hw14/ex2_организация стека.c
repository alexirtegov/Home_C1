/*
Указатель на первую структуру списка обычно называют head (голова списка). Вот как это объявляется и используется:
Объявление указателя на первый элемент struct Node* head = NULL;  // Инициализируем пустым указателем

head - это корневой указатель, который всегда указывает на первый элемент списка
Если список пуст - head = NULL
При добавлении/удалении элементов мы всегда работаем через head
 */


// Пример организации стека как однонаправленного списка#include <stdio.h>

#include <stdio.h>
#include <stdlib.h>

//объявляем структуру узла
struct Node
{
	int data;
	struct Node *next; //указатель на следующую структуру
};


int main()
{
	//1. Объявляем указатель на первый элемент
	struct Node*head = NULL;
	// struct Node* — Это объявление указателя на структуру с тегом Node.
	// head — Имя переменной-указателя. Это ваша главная точка доступа к списку.
	// = NULL — Инициализация указателя нулевым значением. ("ни на что не указывает".)
	
	//2. Создаем первый узел
	head = (struct Node*)malloc(sizeof(struct Node));
	//выделяет в динамической памяти («куче») ровно столько байт, сколько требуется для хранения одной структуры Node
	//Функция malloc возвращает указатель десь struct Node*, но по умолчапнию тип void*
	//После выполнения этой строки переменная head начинает указывать на только что выделенный непросмотренный кусок памяти, размером с один узел списка.
	head ->data = 10; 	//(*head).data = 10;
	
	// 3. Создаем второй узел
	struct Node* second = (struct Node*)malloc(sizeof(struct Node));
	second ->data = 20;
	second ->next = NULL; //Теперь вторая структура (пока) последняя. «second» не указывает на следующий узел – то есть конц списка.
	
	//4. Связываем узлы
	head->next = second;
	
	//5. Создадим третий узел
	struct Node *third = malloc(sizeof(struct Node)); //явное приведение к типу struct Node* избыточно, требуется подключение библиотеки <stdlib.h>
	third ->data = 30;
	third ->next = NULL; 	// изначально третий — тоже «конец»
	
	// 6. Перенаправляем указатель второго узла
	second->next = third; //то берём адрес, хранящийся в переменной third (то есть адрес третьего узла), и записываете его в поле next второго узла. 
	// Теперь список выглядит так:
	// head → [10|*] → second → [20|*] → third → [30|NULL]
	
	
	//7. Работаем со списком через head 
	printf("first element: %d\n", head->data);					//10
	printf("second element: %d\n",second ->data);			//20
	printf("third element: %d\n", head->next->next->data);		//30
	
	//8. Освобождаем память (важно!)
	free(head);
	free(second);
	free(third);

	
    return 0;
}

//Визуализация в памяти:
//head [0x1000]  -->  [Первый узел по адресу 0x1000]
//								data: 10
//								next: 0x2000  -->  [Второй узел по адресу 0x2000]
//															data: 20
//															next: 0x3000	-->		[Третий узел по адресу 0x3000]	
//																								data: 30
//																								next: NULL
