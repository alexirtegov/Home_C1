/*
F7-Упаковать массив 0 1

Написать функцию, которая сжимает серии массива, 
состоящего из единиц и нулей по следующему принципу: 
например, массив [0,0,0,0,1,1,1,1,1,1,1,0,0,1,1,1,1] 
преобразуется в [4,7,2,4] (т.к. начинается с нуля, 
то сразу записывается количество элементов первой серии); 
а массив [1,1,1,0,0,0,0,0,0,0] преобразуется в [0,3,7] 
(т.к. первая серия - это единицы, то первый элемент 
преобразованного массива 0).



Формат входных данных:
Функция принимает исходный массив a[] и сжимает в массив b[], 
N - число элементов в массиве a[].


Input
0 0 1 0 0 1 1 0 0 1 1 0 1 0 0 1 1 0 1 0 1 1 1 1 0 1 1 1 1 0 0 0 0 1 1 0 0 1 0 1 0 1 1 1 0 1 0 1 1 0 1 1 1 0 0 0 0 1 0 1 0 0 0 1 0 1 1 1 1 1 0 1 0 1 1 1 0 0 0 1 0 1 1 1 1 0 1 1 1 0 0 1 1 1 1 0 1 0 1 1


Формат результата:
Функция возвращает число элементов сжатого массива b[]

Output
[2,1,2,2,2,2,1,1,2,2,1,1,1,4,1,4,4,2,2,1,1,1,1,3,1,1,1,2,1,3,4,1,1,1,3,1,1,5,1,1,1,3,3,1,1,4,1,3,2,4,1,1,1,2]
Решение:
Сжать массив из нулей и единиц можно следующим образом. 
Сначала определяем, с какой серии мы будем вести отсчёт — 
всегда «нулевой»: то есть внешняя логика такова, что мы считаем, 
сколько подряд нулей, затем сколько подряд единиц, потом снова нулей, 
и так до конца массива. 
Если же реальный первый элемент массива оказался единицей, 
то перед всеми реальными сериями единиц «запишем» нулевую серию нулей длиной 0.

После этого начинаем сканировать исходный массив последовательно. Держим два состояния:
– ожидаемое значение серии (0 или 1)
– счётчик длины текущей серии

До тех пор, пока очередной элемент совпадает с ожидаемым, 
мы просто увеличиваем счётчик. Как только встречаем элемент, 
отличный от ожидаемого, мы «заканчиваем» текущую серию: 
записываем во вспомогательный массив длину счётчика, 
переключаем ожидаемое значение на противоположное 
(если было 0 – станет 1, если 1 – станет 0), 
обнуляем счётчик и сразу считаем первый элемент новой серии 
(то есть присваиваем счётчику 1). Затем продолжаем тот же процесс: 
пока очередные элементы равны новому ожидаемому значению, 
инкрементируем счётчик, при изменении – фиксируем и переключаемся снова.

Когда доходим до конца исходного массива, 
у нас остаётся непомещённая в вывод последняя серия, 
поэтому её длину тоже записываем. В результате во 
вспомогательном массиве окажется чередование длин серий нулей и единиц, 
причём, благодаря начальной проверке, если исходный массив начинался 
с единиц, перед первой ненулевой серией единиц будет стоять ноль. 
Именно так для заданных входных данных получается последовательность
[2,1,2,2,2,2,1,1,2,2,1,1,1,4,1,4,4,2,2,1,1,1,1,3,1,1,1,2,1,3,4,1,1,1,3,1,1,5,1,1,1,3,3,1,1,4,1,3,2,4,1,1,1,2].
*/


#include <stdio.h>
#define SIZE 100

int compression(int a[], int b[], int N)
{
	int count_b = 0;
	
	
	if(a[0] ==1){ //если первый член массива равен 1
		b[count_b]=0; //записываем нулевую серию нулей
		count_b++;
	}
	
	for(int i=0; i<N;){
	
		int run_len =1;
		while (i+run_len<N && a[i + run_len] == a[i]){
		run_len++;
		}
		
		b[count_b] = run_len;
		count_b++;
		i+=run_len;
		
	}
	
	return count_b;
}

void Input_array(int array[], int n)
{
	for(int i=0; i<n; i++){
		scanf("%d", &array[i]);
	}
}

int main(int argc, char **argv)
{
	int array[SIZE];
	Input_array(&array[0], SIZE);
	
	int b[SIZE]={0};
	
	int count_b = compression(array, b, SIZE);
	
	for(int i=0; i<count_b; i++){
	printf("%d ", b[i]);
	}
		
	return 0;
}

