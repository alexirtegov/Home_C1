/*
getopt() - "умный" парсер аргументов (встроен в Linux/macOS)
"hf:" - шаблон флагов:
h - флаг без параметра
f: - флаг С параметром (двоеточие означает ожидание значения)

### Пример 1: Вызов с флагом `-h`
```bash
./myprogram -h
```

Шаги выполнения:
1. `main` вызывается с аргументами:
   - `argc = 2`
   - `argv[0] = "./myprogram"`
   - `argv[1] = "-h"`

2. Объявляются переменные:
   - `char dir[PATH_LENGTH]` - массив для хранения пути (пока не инициализирован)
   - `char buf[PATH_LENGTH]` - аналогично
   - `int rez = 0` - будет хранить текущий обрабатываемый флаг

3. Входим в цикл `while`, где вызывается `getopt(argc, argv, "hf:")`:
   - Первый вызов `getopt` обрабатывает `-h`.
   - `getopt` возвращает `'h'`.

4. В `switch` попадаем в `case 'h':`
   - Выводим несколько строк с помощью `printf`:
     ```c
     printf("This is example of list directory\n");
     printf("Usage: clear [options]\n\
     -h This help text\n\
     -f Specify folder.\n");
     printf("Example: %s -f /tmp\n", argv[0]); // Здесь %s заменяется на "./myprogram"
     ```
   - Затем выполняется `return 0;` — программа завершается.

Вывод на экран будет примерно таким:
```
This is example of list directory
Usage: clear [options]
-h This help text
-f Specify folder.
Example: ./myprogram -f /tmp
```



### Пример 2: Вызов с флагом `-f`
```bash
./myprogram -f /home/user/Documents
```

Шаги:
1. Аргументы:
   - `argc = 3`
   - `argv[0] = "./myprogram"`
   - `argv[1] = "-f"`
   - `argv[2] = "/home/user/Documents"`

2. Переменные объявлены.

3. Цикл `while`:
   - `getopt` вызывается первый раз:
     - Видит флаг `-f`, который требует аргумент (потому что в строке `"hf:"` после `f` стоит двоеточие).
     - Следующий аргумент (`/home/user/Documents`) будет взят как значение для `-f`.
     - `getopt` возвращает `'f'`.
   - В `switch` переходим в `case 'f':`
     - `printf("folder is \"f = %s\".\n", optarg);` — выведет: `folder is "f = /home/user/Documents".`
     - `strcpy(dir, optarg);` — копирует строку `optarg` (которая сейчас указывает на `"/home/user/Documents"`) в массив `dir`.

   - Затем `break` — выходим из `switch`.

   - Цикл `while` продолжается: `getopt` вызывается снова. Больше флагов нет, поэтому `getopt` возвращает `-1`. Выходим из цикла.

4. После цикла идут закомментированные строки. Они не выполняются.

5. Программа завершается: `return 0;


### Пример 3: Неизвестный флаг
```bash
./myprogram -x
```

Шаги:
1. Аргументы:
   - `argc = 2`
   - `argv[0] = "./myprogram"`
   - `argv[1] = "-x"`

2. Переменные объявлены.

3. Цикл `while`:
   - `getopt` видит флаг `-x`, который не указан в строке `"hf:"`.
   - Поэтому `getopt` возвращает `?` (вопросительный знак).

4. В `switch` переходим в `case '?':`
   - `printf("Unknown argument: %s Try -h for help\n", argv[optind - 1]);`
     - `optind` — это индекс следующего аргумента для обработки. В данном случае, после обработки `-x`, `optind` станет равным 2 (потому что обработали один аргумент).
     - `argv[optind - 1]` — это `argv[1]`, то есть `"-x"`.
   - Вывод: `Unknown argument: -x Try -h for help`
   - `return 1;` — программа завершается с кодом ошибки.
   
   
   ### Пример 4: Флаг `-f` без аргумента
```bash
./myprogram -f
```

Шаги:
1. Аргументы:
   - `argc = 2`
   - `argv[0] = "./myprogram"`
   - `argv[1] = "-f"`

2. `getopt` видит `-f`, который требует аргумент, но следующего аргумента нет. Поэтому `getopt` возвращает `?`.

3. В `case '?':`:
   - `printf` выведет: `Unknown argument: -f Try -h for help`
   - Потому что `getopt` сам поставит `optopt` в `'f'` (мы его не используем), а в `argv[optind-1]` будет `"-f"`.

Однако, обрати внимание: в данном случае сообщение будет не совсем точным, потому что проблема не в том, что флаг неизвестный, а в том, что он требует аргумент. Но в нашем коде мы обрабатываем и ту, и другую ситуацию в одном случае `'?'`. Чтобы различать эти ситуации, можно использовать глобальную переменную `optopt` (для этого нужно подключить заголовочный файл `<getopt.h>`). Но в данном коде этого нет.

### Важные замечания:
- Порядок аргументов может быть любым (например, `./myprogram -h -f /tmp`), но так как при обработке `-h` программа завершается, то `-f` не будет обработан.
- Если вызвать `./myprogram -f /tmp -h`, то сначала обработается `-f`, а потом `-h` (и программа завершится). Но в нашем коде после обработки `-f` мы не выходим из программы, поэтому дойдем до `-h` и выведем справку.

### Разбор внутреннего состояния при вызове `./myprogram -f /tmp -h`:
1. Первый вызов `getopt`:
   - Обрабатывает `-f`, для него требуется аргумент — берет следующий аргумент `"/tmp"`.
   - Возвращает `'f'`.
   - В `case 'f'`: 
     - Выводит `folder is "f = /tmp".`
     - Копирует `"/tmp"` в `dir`.
   - `break` — выходим из `switch`, цикл продолжается.

2. Второй вызов `getopt`:
   - Обрабатывает `-h`.
   - Возвращает `'h'`.
   - В `case 'h'`: выводит справку и завершает программу (`return 0`).

Таким образом, в этом случае мы сначала обработаем `-f`, а затем `-h`.
 
 ### Разбор внутреннего состояния при вызове `./myprogram -f /tmp -h`:
1. Первый вызов `getopt`:
   - Обрабатывает `-f`, для него требуется аргумент — берет следующий аргумент `"/tmp"`.
   - Возвращает `'f'`.
   - В `case 'f'`: 
     - Выводит `folder is "f = /tmp".`
     - Копирует `"/tmp"` в `dir`.
   - `break` — выходим из `switch`, цикл продолжается.

2. Второй вызов `getopt`:
   - Обрабатывает `-h`.
   - Возвращает `'h'`.
   - В `case 'h'`: выводит справку и завершает программу (`return 0`).

Таким образом, в этом случае мы сначала обработаем `-f`, а затем `-h`.

 */


#include <stdio.h>      // Для ввода/вывода (printf)
#include <unistd.h>     // Для getopt() и работы с ОС
#define PATH_LENGTH 255 // Максимальная длина пути к папке

int main(int argc, char *argv[])  // argc - кол-во аргументов, argv - их значения
{
    char dir[PATH_LENGTH], buf[PATH_LENGTH]; // Буферы для хранения путей
    int rez = 0; // Переменная для хранения текущего флага
    // opterr=0; // Закомментировано - отключает авто-вывод ошибок
    
  while ((rez = getopt(argc, argv, "hf:")) != -1)
  {
    switch (rez)
    {
    case 'h':	 // Обработка флага -h
      printf("This is example of list directory\n");
      printf("Usage: clear [options]\n\
        -h This help text\n\
        -f Specify folder.\n");
        
      printf("Example: %s -f /tmp\n", argv[0]);
      return 0; //после обработки флага h программа завершается
      
    case 'f': 
      printf("folder is \"f = %s\".\n",optarg); //Видит флаг `-f`, который требует аргумент (потому что в строке `"hf:"` после `f` стоит двоеточие).
      strcpy(dir, optarg); //— копирует строку `optarg` (которая сейчас указывает например на `"/home/user/Documents"`) в массив `dir`.
      break;
    case '?':
      printf("Unknown argument: %s Try -h for help\n", argv[optind - 1]);
      //это индекс следующего аргумента для обработки. В данном случае, после обработки `-x`, `optind` станет равным 2 (потому что обработали один аргумент).
      return 1;
    };
  };
  // convert_path_to_full(buf, dir);
  // printf("ls for folder %s\n",buf);
  // ls(dir);
  return 0;
}
