/*
Этап 1: Базовая структура и ввод пути
Объяснение:
Этот фрагмент программы преобразует пользовательский ввод пути в абсолютный путь и гарантирует, 
что путь заканчивается символом /.

Цель: Преобразование введённого пути в абсолютный формат.
Функция convert_path_to_full:
Если путь начинается с / (абсолютный) — копируем как есть.
Если начинается с . — используем текущую директорию (getcwd).
Иначе — комбинируем текущую директорию с введённым путём.
Всегда добавляем / в конец для корректной конкатенации имён файлов.

Для чего это нужно?
Этот код подготавливает пути для последующей обработки в файловых операциях, где требуется:

Единый формат путей
Гарантированное наличие / в конце для конкатенации с именами файлов
Преобразование пользовательского ввода в абсолютные пути

Ввод пользователя	Текущая директория	Результат (вывод)
	/usr				Любая		    	/usr/
	
	  .				/home/user			  /home/user/
	  
 Documents			  /home			    /home/Documents/
 
   ./src	          /projects			/projects/src/
  
  ../parent			  /home/user		/home/user/../parent/
*/

#include <stdio.h>
#include <string.h> 
// здесь size_t strlen(const char *s)
// получает указатель на строку s, идёт по символам до первого '\0' 
//и возвращает число пройденных символов (не включая завершающий нуль). 
//Например, для строки "hello" она вернёт 5.

#include <unistd.h> 
//для getcwd:
//Мы объявляем буфер `full_path` размером `PATH_LENGTH` (256 байт). 
//Функция `getcwd` (get current working directory) записывает в этот буфер текущий рабочий каталог.

//Параметры функции `getcwd`:
//- Первый параметр: указатель на буфер, куда будет записан путь.
//- Второй параметр: размер этого буфера.


#define PATH_LENGTH 256
#define STR255 "%255s"

void convert_path_to_full(char *full_path, const char *dir) {
    if (dir[0] == '/') {
        strcpy(full_path, dir);          // Абсолютный путь (начинается с /), при совпадении копируем strcpy из массива dir строку в full_path как есть
		//ввод: /usr/local/bin
		//Работа условия: dir[0] = '/' → условие истинно ✅ strcpy(full_path, "/usr/local/bin")
		// После этого добавляется / в конец: full_path = "/usr/local/bin/"

    } else if (dir[0] == '.') {
        getcwd(full_path, PATH_LENGTH);  // Относительный путь с точкой (текущая директория)
        //Функция `getcwd` получает абсолютный путь текущей рабочей директории и сохраняет его в буфер `full_path`
        //ввод '.'
        //getcwd() запишет в full_path: C:\git\Home_C1\hw13 command line arguments и добавит в конец /
        
    } else {
        getcwd(full_path, PATH_LENGTH);  // относительный путь без точки (просто имя папки)
        //getcwd Получаем текущую рабочую директорию и сохраняем в `full_path
        strcat(full_path, "/");
        //strcat  добавляет вторую строку с символом / в конец первой.
        strcat(full_path, dir);
        // Теперь добавляем к `full_path` строку `dir` (введенную пользователем).
    }
    // Добавляем / в конец если отсутствует
    if (full_path[strlen(full_path) - 1] != '/')
    //мы читаем full_path и считаем длину массива, сравниваем последний с '/' и если '/' нет, добавлем
        strcat(full_path, "/"); //добавляем '/' если его нет
}

int main() 
 {
    char dir[PATH_LENGTH]; //Запрашивает у пользователя путь
    char full_path[PATH_LENGTH];
    printf("Input dir: "); 
    scanf(STR255, &dir[0]);  // Безопасный ввод (до 255 символов)
    
    convert_path_to_full(full_path, dir);
    printf("Full path: %s\n", full_path);
    
    return 0;
}
