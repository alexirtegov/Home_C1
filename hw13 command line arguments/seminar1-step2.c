/*
Этап 2: Базовая структура и ввод пути
Каждый раз, когда вы подключаете заголовок

#include <dirent.h>
вам становится доступно две «черные коробки»:

Тип DIR (реально это typedef struct __dirstream DIR;) — внутренняя структура, 
в которой libc хранит состояние «открытой папки» 
(файловый дескриптор, буфер для чтения записей, текущую позицию и т. д.).

Тип struct dirent — структура, в которую будут раскладываться отдельные записи каталога 
(имя файла, номер inode, тип и т. п.).

Вы вызываете
DIR *folder = opendir(full_path);
Например, если full_path равен строке ".", то внутри:
– libc сделает open(“.”, O_RDONLY | O_DIRECTORY), получит файловый дескриптор.
– через malloc или внутренний аллокатор выделит память под struct __dirstream (наш DIR).
– проинициализирует в ней поля:
• dd_fd — тот самый дескриптор,
• dd_loc = 0 и dd_size = 0 (пока буфер пуст),
• может выделить дополнительный буфер, куда будет читать «сырые» записи через 
системный вызов getdents.
– вернёт вам указатель folder на эту структуру.

«struct dirent *entry;»
– Здесь мы объявляем переменную entry.
– Она имеет тип «указатель на структуру dirent».
– Структура dirent описана в заголовке <dirent.h> (POSIX-совместимая). В ней, в частности, есть поле
     char d_name[256]; - это место, куда система помещает имя очередного файла или папки.  
 – Саму память под эту структуру мы не выделяем вручную. 
 Мы лишь говорим: «entry будет указывать на ту память, 
 которую мне даст система при каждом вызове readdir».
«while ((entry = readdir(folder))) { … }»
– Это главный цикл обхода. Функция readdir по POSIX-спецификации берёт указатель folder 
(его мы получили раньше из opendir) и возвращает:   

• Указатель на заполненную запись struct dirent — если в каталоге ещё остались файлы/папки.
• NULL — когда записи закончились или произошла ошибка.
– Выражение (entry = readdir(folder)) сначала выполняет присваивание, 
а затем возвращает само значение присвоения. Цикл while продолжится только пока entry не стал NULL.

«if (entry->d_name[0] == '.') continue;»
– Оператор -> используется для доступа к полям структуры через указатель.
– Здесь мы смотрим первый символ имени (d_name[0]). Если он точка ('.'), 
значит это либо «.» (текущая папка), либо «..» (родительская), либо файл, 
имя которого начинается с точки (на UNIX-платформах обычно это «скрытый» файл). 
Мы просто пропускаем такие записи оператором continue, возвращаемся 
к проверке условия цикла и дальше не печатаем их.



*/

#include <stdio.h> //даёт вам функцию printf и scanf для ввода-вывода.

#include <string.h>  //нужен для работы со строками: там объявлены strlen, strcpy, strcat.
// здесь size_t strlen(const char *s)
// получает указатель на строку s, идёт по символам до первого '\0' 
//и возвращает число пройденных символов (не включая завершающий нуль). 
//Например, для строки "hello" она вернёт 5.

#include <unistd.h>  // содержит прототип getcwd (получение текущей директории).
//Функция getcwd(full_path, PATH_LENGTH); записывает в этот буфер текущий рабочий каталог.
//Параметры функции `getcwd`:
//- Первый параметр: указатель на буфер, куда будет записан путь.
//- Второй параметр: размер этого буфера.

#include <dirent.h> //даёт функции для работы с директориями: opendir, readdir, closedir, и тип struct dirent.

enum { PATH_LENGTH = 256 }; //создаёт в области компиляции целочисленную константу PATH_LENGTH, равную 256

//#define PATH_LENGTH 256 - просто текстом подставялется 256
#define STR255 "%255s"



void convert_path_to_full(char *full_path, const char *dir) {
    if (dir[0] == '/') {
        strcpy(full_path, dir);          // Абсолютный путь (начинается с /), при совпадении копируем strcpy из массива dir строку в full_path как есть
		//strcpy копирует строку из массива dir в массив full_path

    } else if (dir[0] == '.') {
        getcwd(full_path, PATH_LENGTH);  // Относительный путь с точкой (текущая директория)
        //getcwd(full_path, PATH_LENGTH) заполняет массив full_path (длина 256) строкой адреса рабочего каталога вида "/home/user/project".
        
    } else {
        getcwd(full_path, PATH_LENGTH);  // относительный путь без точки (просто имя папки)
        strcat(full_path, "/"); //strcat  добавляет вторую строку с символом / в конец первой.
        strcat(full_path, dir); // Теперь добавляем к `full_path` строку `dir` (введенную пользователем).
    }
   
    if (full_path[strlen(full_path) - 1] != '/')
    //мы читаем full_path и считаем длину массива, сравниваем последний с '/' и если '/' нет, добавлем
        strcat(full_path, "/"); //добавляем '/' если его нет
}

int main() 
 {
    char dir[PATH_LENGTH]; //Запрашивает у пользователя путь
    char full_path[PATH_LENGTH];
    printf("Input dir: "); 
    scanf(STR255, &dir[0]);  // Безопасный ввод (до 255 символов)
    
    convert_path_to_full(full_path, dir);
    printf("Files in folder %s:\n", full_path); //выведет только адрес рабочего каталога

    
    //В заголовке <dirent.h> (POSIX-стандарт) объявлен тип typedef struct __dirstream DIR;
    //где __dirstream – внутренняя реализация этой структуры.
    //То есть DIR — это через typedef переименованная внутренняя структура (обычно struct __dirstream)
    //DIR *folder это указатель на DIR
    DIR *folder = opendir(full_path); //открыть каталог с именем name (ваш full_path)
   //внутри себя выделяет (или инициализирует) область памяти под объект типа DIR, заполняет туда служебные поля
   //Если он вернул NULL, значит не получилось открыть папку 
   //(нет прав, нет такой папки и т. п.) 
   //и мы выводим системную ошибку через perror и завершаем программу.
   //«НЕ-NULL указатель» — указатель указывает на реальную область памяти, а не равен нулю.
   
      if (folder==NULL) {
        perror("Unable to read directory");
        return 1;
    }

    struct dirent *entry; //— это просто объявление указателя на ту самую структуру, описанную в <dirent.h>.
    int count = 0;
    while ((entry = readdir(folder))) {
        // Пропускаем скрытые файлы и директории (начинающиеся с '.')
        if (entry->d_name[0] == '.') 
            continue;
        printf("%s\n", entry->d_name); //здесь мы печатаем все файлы
        count++;
    }
    printf("Total: %d files\n", count);
    closedir(folder);
    return 0;
}
