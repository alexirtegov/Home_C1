/*
Мы имеем макрос TOSTR(a), который использует оператор # (stringizing) 
для преобразования своего аргумента в строковый литерал.
Оператор # в макросе преобразует лексемы аргумента в строку. 
Важно: аргумент не расширяется, если он является макросом, 
если только макрос не используется с оператором ## 
или в подобных контекстах. Но в данном случае, просто #a.

Макрос TOSTR
#define TOSTR(a) #a
#a — это оператор stringizing в препроцессоре C.
Его задача: преобразовать любой переданный аргумент в строковый литерал.
Работает на этапе препроцессинга (до компиляции).

Как работает оператор #
Берет лексемы (токены), переданные в аргументе a.
Объединяет их в одну строку.
Добавляет кавычки " вокруг результата.
Экранирует внутренние кавычки (если они есть).


Первый вызов: TOSTR(hello world)
printf("%s\n", TOSTR(hello world));
После препроцессинга:
printf("%s\n", "hello world");
Почему так?
Аргумент hello world — два отдельных идентификатора.
Препроцессор объединяет их в одну строку с пробелом.
Вывод: hello world

Второй вызов: TOSTR(123)
printf("%s\n", TOSTR(123));
После препроцессинга:
  printf("%s\n", "123");
Почему так?
Число 123 преобразуется в строку "123".
Вывод: 123


Третий вывод: TOSTR("hello world")
printf("%s\n", TOSTR("hello world"));
После препроцессинга:
  printf("%s\n", "\"hello world\"");
Почему так?
Аргумент — строковый литерал "hello world".
Оператор # экранирует внутренние кавычки: \" → ".
Результат: "\"hello world\"" (что соответствует строке "hello world" при выводе).
Вывод: "hello world"

Ключевые особенности
Текстовая подстановка:
Макрос работает с исходным текстом, а не со значениями.
Пример: TOSTR(2 + 2) → "2 + 2" (а не "4").
 */


#include <stdio.h>

//Преобразование аргумента в строку
#define TOSTR(a) #a

int main(void)
{
    printf("%s\n",TOSTR(hello world));
    printf("%s\n",TOSTR(123));
    printf("%s\n",TOSTR("hello world"));
    return 0;
}
